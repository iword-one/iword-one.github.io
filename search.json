[{"title":"git与github的授权认证","url":"/2024/10/20/git%E4%B8%8Egithub%E7%9A%84%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81/","content":"一、进行本地git信息配置git config --global user.username xxxxxgit config --global user.email xxxxx@github.comssh-keygen -t rsa -C xxxx@github.com #本地生成私钥和密钥信息 生成之后，会在本地的 C:\\Users\\用户名/.ssh/id_rsa 和C:\\Users\\用户名/.ssh/id_rsa.pub\n二、进行git与github的授权认证在github设置页面，选择左侧的  SSH and GPG keys 内容，右侧新增一个SSH key，上一步id_rsa.pub公钥文件的内容作为SSH秘钥添加到github中，title可以任意填写。\n最后，使用控制台命令：ssh -T &#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;检查是否可以远程通信，如果出现Hi…你的github账户名称的内容，说明授权成功。\n","tags":["GitHub"]},{"title":"一个node.js版本管理工具nvm","url":"/2024/10/20/%E4%B8%80%E4%B8%AAnode-js%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7nvm/","content":"nvm是什么nvm全英文也叫node.js version management，是一个nodejs的版本管理工具。nvm和n都是node.js版本管理工具，为了解决node.js各种版本存在不兼容现象可以通过它可以安装和切换不同版本的node.js。下载地址：https://github.com/coreybutler/nvm-windows/releases\n一、nvm命令提示\nnvm arch：显示node是运行在32位还是64位。\nnvm install  [arch] ：安装node， version是特定版本也可以是最新稳定版本latest。可选参数arch指定安装32位还是64位版本，默认是系统位数。可以添加–insecure绕过远程服务器的SSL。\nnvm list [available] ：显示已安装的列表。可选参数available，显示可安装的所有版本。list可简化为ls。\nnvm on ：开启node.js版本管理。\nnvm off ：关闭node.js版本管理。\nnvm proxy [url] ：设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。\nnvm node_mirror [url] ：设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。\nnvm npm_mirror [url] ：设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。\nnvm uninstall  ：卸载指定版本node。\nnvm use [version] [arch] ：使用制定版本node。可指定32&#x2F;64位。\nnvm root [path] ：设置存储不同版本node的目录。如果未设置，默认使用当前目录。\nnvm version ：显示nvm版本。version可简化为v。\n\n二、nvm切换国内镜像如果下载node过慢或者安装失败，请更换国内镜像源, 在 nvm 的安装路径下，找到 settings.txt，设置node_mirro与npm_mirror为国内镜像地址。下载就飞快了~~\nroot: D:\\nvmpath: D:\\nodejsnvm npm_mirror https://npmmirror.com/mirrors/npm/nvm node_mirror https://npmmirror.com/mirrors/node/或者：node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/\n\n三、安装node.js版本nvm list available #显示可下载版本的部分列表nvm install latest #安装最新版本 ( 安装时可以在上面看到 node.js 、 npm 相应的版本号 ，不建议安装最新版本)nvm install 8.12.0 #安装指定的版本8.12.0的nodejs\n四、查看已安装版本nvm list或nvm ls #查看目前已经安装的版本 （ 当前版本号前面没有 * ， 此时还没有使用任何一个版本，这时使用 node命令会报错 ）nvm use 8.12.0 #使用指定版本的nodejs （ 这时会发现在启用的 node 版本前面有 * 标记，这时就可以使用 node.js ）","categories":["nvm"],"tags":["nvm","node"]},{"title":"上传GitHub仓库流程","url":"/2024/10/20/%E4%B8%8A%E4%BC%A0GitHub%E4%BB%93%E5%BA%93%E6%B5%81%E7%A8%8B/","content":"从克隆项目到修改并上传到自己 GitHub 仓库的流程（包括私钥配置）\n生成 SSH 密钥\n\n如果还没有生成 SSH 密钥，可以通过以下命令生成：ssh-keygen -t rsa -C &quot;your-email@example.com&quot;\n系统会提示你保存密钥的位置，通常保存在 ~/.ssh/id_rsa，如果不需要加密密码，直接按回车。\n\n\n添加 SSH 公钥到 GitHub\n\n将生成的公钥添加到 GitHub：\n复制公钥到剪贴板：cat ~/.ssh/id_rsa.pub\n登录 GitHub，进入 SSH 和 GPG 密钥设置页面。\n点击 “New SSH key”，将复制的公钥粘贴进去，添加密钥。\n\n\n\n\n测试 SSH 连接\n\n测试 SSH 是否能连接到 GitHub：ssh -T git@github.com\n如果连接成功，会显示类似 “Hi username! You’ve successfully authenticated” 的信息。\n\n\n克隆项目到本地\n\n从别人的仓库克隆项目，使用 SSH 地址：git clone git@github.com:username/repository.git\n\n\n进入项目文件夹\n\n进入克隆到本地的项目文件夹：cd repository\n\n\n修改项目代码\n\n在本地编辑和修改代码，可以使用任何代码编辑器。\n\n\n初始化并关联自己的仓库\n\n如果没有初始化 Git 仓库：git init\n将本地仓库的远程地址更改为你自己的 GitHub 仓库（使用 SSH）：git remote set-url origin git@github.com:your-username/your-repository.git\n查看当前分支：git branch \n新建分支：git checkout -b master\n查看远程仓库地址： git remote -v\n远程仓库地址新增： git remote add origin &#103;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;:your-username&#x2F;your-repository.git\n\n\n添加文件到 Git 暂存区\n\n将修改后的文件添加到暂存区：git add .\n\n\n提交修改\n\n提交修改并添加提交信息：git commit -m &quot;Your commit message&quot;\n\n\n推送代码到自己的 GitHub 仓库\n\n将本地修改推送到自己的 GitHub 仓库：git push origin master\n如果是第一次推送：git push -u origin master\n\n\n\n总结通过使用 SSH 密钥，能够安全地与 GitHub 通信，避免每次推送代码时输入用户名和密码。这个流程涵盖了生成和配置 SSH 密钥，克隆项目，修改代码，以及推送到自己的 GitHub 仓库的完整步骤。\n","tags":["GitHub"]},{"title":"安装Hexo","url":"/2024/10/20/%E5%AE%89%E8%A3%85Hexo/","content":"安装 Hexo 相当简单，只需要先安装下列应用程序即可：https://hexo.io/zh-cn/docs/setup\n\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) 推荐使用nvm\nGit\n\n安装hexo$ npm config set registry https://mirrors.huaweicloud.com/repository/npm/ #修改成华为云镜像源$ npm config get registry #验证命令，如果返回https://mirrors.huaweicloud.com/repository/npm/，说明镜像配置成功。$ npm install -g hexo-cli\n$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ hexo g$ hexo s\n修改配置文件_config.ymldeploy:  type: git  repository: https://github.com/iword-one/iword-one.github.io.git  branch: main\n切记，在上传前面还要安装插件hexo-deployer-git\nnpm install --save hexo-deployer-git\n上传到githubgit与github授权认证\nhexo deploy\n 相关文章：nvm 一个node版本管理工具 \n","categories":["Hexo"],"tags":["Node","Git","Hexo"]},{"title":"快速学会使用django","url":"/2024/08/06/%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8django/","content":"下面是从零开始开发 Django 项目的完整步骤，包括环境设置、项目配置、Django REST framework (DRF) 的准备工作，以及跨域资源共享 (CORS) 的配置  \n一、环境设置1.1 创建虚拟环境使用 Python 的虚拟环境工具隔离项目的依赖：\npython -m venv venv source venv/bin/activate  # 在 Windows 上使用 &#x27;venv\\Scripts\\activate&#x27; \n\n\n1.2 安装 Django 和 Django REST framework安装 Django 和 Django REST framework（DRF）：\npip install django djangorestframework\n1.3 安装 CORS 支持库安装 django-cors-headers 库以支持跨域资源共享 (CORS)：\npip install django-cors-headers\n1.4 保存依赖项将依赖项保存到 requirements.txt 文件中，方便后续管理和部署：\npip freeze &gt; requirements.txt\n\n\n二、项目配置2.1 创建 Django 项目使用 Django 的命令行工具创建新的项目：\ndjango-admin startproject myproject\n\n2.2 创建 Django 应用在项目目录下创建应用（例如 myapp）：\ncd myprojectpython manage.py startapp myapp\nDjango项目目录结构\n\n\n\n2.3 配置项目设置在 settings.py 中添加应用和 DRF\nINSTALLED_APPS = [    ...    &#x27;rest_framework&#x27;, #添加drf框架    &#x27;myapp&#x27;, #添加应用    &#x27;corsheaders&#x27;,  # 添加 CORS 支持]\n2.4 配置中间件以启用 CORS在 settings.py 中的 MIDDLEWARE 列表中添加 corsheaders.middleware.CorsMiddleware：\nMIDDLEWARE = [    ...    &#x27;corsheaders.middleware.CorsMiddleware&#x27;,    &#x27;django.middleware.common.CommonMiddleware&#x27;,    ...]\n\n2.5 配置 CORS 设置在 settings.py 中添加 CORS 配置：\nCORS_ALLOWED_ORIGINS = [    &quot;http://localhost:3000&quot;,  # 你的前端应用 URL    &quot;https://yourfrontenddomain.com&quot;,  # 生产环境中的前端 URL]\n2.6 设置数据库（默认是 SQLite，可以根据需要修改）：DATABASES = &#123;    &#x27;default&#x27;: &#123;        &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,        &#x27;NAME&#x27;: BASE_DIR / &#x27;db.sqlite3&#x27;,    &#125;&#125;\n\n2.7 配置静态文件\n如有必要）：’DIRS’: [Path(BASE_DIR, ‘templates’)],\n\nSTATIC_URL = &#x27;/static/&#x27;STATICFILES_DIRS=[BASE_DIR,&#x27;static&#x27;]#或者STATICFILES_DIRS = [os.path.join(BASE_DIR, &#x27;static&#x27;)]#STATIC_ROOT=Path(BASE_DIR,&#x27;static&#x27;)#(开发环境不需要，上一行和这一行不能指定为同一个目录)在生产环境时，运行python manage.py collectstatic,django会将所有静态文件拷贝到Static目录中。\n2.8 配置媒体文件（如果需要上传文件）：MEDIA_URL = &#x27;/media/&#x27;MEDIA_ROOT = Path(BASE_DIR, &#x27;media&#x27;)\n2.9 设置语言和时区（根据需要）：# 将 LANGUAGE_CODE 改为中文LANGUAGE_CODE = &#x27;zh-hans&#x27;# 将 TIME_ZONE 改为中国标准时间TIME_ZONE = &#x27;Asia/Shanghai&#x27;\n\n\n2.10 准备 Django REST framework\n配置 DRF，在 settings.py 中添加 DRF 的配置（如果有特定需求）：\n\nREST_FRAMEWORK = &#123;    &#x27;DEFAULT_RENDERER_CLASSES&#x27;: (        &#x27;rest_framework.renderers.JSONRenderer&#x27;,    ),    &#x27;DEFAULT_PARSER_CLASSES&#x27;: (        &#x27;rest_framework.parsers.JSONParser&#x27;,    ),&#125;\n\n三、编写后端代码3.1 创建模型在 myapp&#x2F;models.py 中定义数据模型：\nfrom django.db import modelsclass Word(models.Model):    head_word = models.CharField(max_length=100)    data = models.JSONField()\n\n3.2 创建序列化器在 myapp&#x2F;serializers.py 中定义序列化器：\nfrom rest_framework import serializersfrom .models import Wordclass WordSerializer(serializers.ModelSerializer):    class Meta:        model = Word        fields = &#x27;__all__&#x27;\n\n3.3 创建视图集在 myapp&#x2F;views.py 中定义视图集：\nfrom rest_framework import viewsetsfrom .models import Wordfrom .serializers import WordSerializerclass WordViewSet(viewsets.ModelViewSet):    queryset = Word.objects.all()    serializer_class = WordSerializer\n\n3.4 配置 URL 路由在 myapp&#x2F;urls.py 中配置应用的 URL 路由：\nfrom django.urls import path, includefrom rest_framework.routers import DefaultRouterfrom .views import WordViewSetrouter = DefaultRouter()router.register(r&#x27;words&#x27;, WordViewSet)urlpatterns = [    path(&#x27;&#x27;, include(router.urls)),]\n\n\n\n这个配置将为 Word 模型提供以下 API 端点\n\n\nGET &#x2F;words&#x2F;：获取所有 Word 对象的列表。\nGET &#x2F;words&#x2F;{id}&#x2F;：获取特定 Word 对象的详细信息。\nPOST &#x2F;words&#x2F;：创建一个新的 Word 对象。\nPUT &#x2F;words&#x2F;{id}&#x2F;：更新特定 Word 对象的全部字段。\nPATCH &#x2F;words&#x2F;{id}&#x2F;：部分更新特定 Word 对象的字段。\nDELETE &#x2F;words&#x2F;{id}&#x2F;：删除特定 Word 对象。\n\n3.5 在项目的 myproject&#x2F;urls.py 中包含应用的 URL 路由：from django.contrib import adminfrom django.urls import path, includeurlpatterns = [    path(&#x27;admin/&#x27;, admin.site.urls),    path(&#x27;api/&#x27;, include(&#x27;myapp.urls&#x27;)),#加入api]\n\n\n\n五、数据库初始化和开发5.1 创建数据库表执行迁移命令以创建数据库结构：\npython manage.py makemigrationspython manage.py migrate\n\n5.2 创建超级用户创建一个超级用户来访问 Django 管理后台：\npython manage.py createsuperuser\n\n\n5.3 启动开发服务器启动 Django 开发服务器进行本地开发和测试：\npython manage.py runserver\n\n\n\n通过这些步骤，你可以设置一个 Django 项目，启用Django REST framework进行API开发，并配置跨域资源共享 (CORS) 以允许来自不同源的请求。这将帮助你构建一个功能全面、跨域兼容的应用程序。\n\n六、Django admin后台配置的常用配置#app/admin.pyfrom django.contrib import adminfrom django.db.models.functions import Lowerfrom .models import Word# Register your models here.class WordModelAdmin(admin.ModelAdmin):    list_display = (&#x27;head_word&#x27;,&#x27;trans_pos&#x27;,&#x27;trans_desc&#x27;)    list_editable = [&#x27;trans_desc&#x27;]    readonly_fields = [&#x27;head_word&#x27;]    search_fields = [&#x27;head_word&#x27;]    list_filter = [&#x27;trans_pos&#x27;]#在admin设置排序，只影响admin界面的显示    ordering = (&#x27;head_word&#x27;,)    list_per_page = 5    #若不想默认区分大小写排序，可在模型中的Meta类中修改或者在模型中指定排序#Meta下定义排序将会影响所有通过模型生成的查询集的默认排序    class Meta:        Ordering = [Lower(&#x27;head_word&#x27;)]admin.site.register(Word,WordModelAdmin)\n七、其他7.1 关于json,记住两个常用函数\njson.loads 用于将 JSON 格式的字符串转换为 Python 对象。\n\n\njson.dumps 用于将 Python 对象转换为 JSON 格式的字符串。\n\n\njson.loads 和 json.dumps 是 Python 的 json 模块中的两个核心函数，用于处理 JSON 数据。它们有不同的用途：\n\njson.loads\n\n功能：将 JSON 格式的字符串解析为 Python 对象（如字典、列表）。\n用法：import jsonjson_string = &#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;&#x27;data = json.loads(json_string)print(data)# 输出: &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;&#125;\n\njson.dumps\n\n将 Python 对象转换为 JSON 格式的 字符串。用法：\n\nimport jsondata = &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;&#125;json_string = json.dumps(data, indent=4, ensure_ascii=False)print(json_string)# 输出:# &#123;#     &quot;name&quot;: &quot;John&quot;,#     &quot;age&quot;: 30,#     &quot;city&quot;: &quot;New York&quot;# &#125;\n\n\n参数：obj：要转换为 JSON 的 Python 对象。indent：用于缩进格式化输出，使 JSON 更易读。ensure_ascii：如果为 False，则允许输出非 ASCII 字符（如中文）。\n\n7.2 限流设置：#限流设置 settings.py全局设置限流访问\n&#x27;DEFAULT_THROTTLE_CLASSES&#x27;: [        &#x27;rest_framework.throttling.AnonRateThrottle&#x27;,        &#x27;rest_framework.throttling.UserRateThrottle&#x27;,    ],    &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123;        &#x27;anon&#x27;: &#x27;2/min&#x27;,        &#x27;user&#x27;: &#x27;10/min&#x27;    &#125;\n\n\n如果你是匿名用户，当你的每分钟请求数量累计达到2次时，你将看到如下返回信息。如果你是认证用户，你的每分钟请求数量达到10次时才会被限流。局部设置限流\n\nREST_FRAMEWORK = &#123;    &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: [        &#x27;rest_framework.throttling.AnonRateThrottle&#x27;,        &#x27;rest_framework.throttling.UserRateThrottle&#x27;,    ],    &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123;        &#x27;anon&#x27;: &#x27;2/min&#x27;,        &#x27;user&#x27;: &#x27;10/min&#x27;,        &#x27;limit_per_minute&#x27;:&#x27;5/min&#x27;, # 新增        &#x27;limit_per_hour&#x27;: &#x27;500/hour&#x27;, # 新增    &#125;&#125;\n\n\n\n\nAnonRateThrottle和UserRateThrottle类都是针对单个用户请求进行限流的，而ScopeRateThrottle类是针对不同API接口资源进行限流的，限制的是所有用户对接口的访问总数之和。使用时直接在视图类里通过throttle_scope 属性指定限流范围(scope), 然后在settings.py对不同scope设置限流频率。\n\n例子如下所示：\nclass ArticleListView(APIView):    throttle_scope = &#x27;article_list&#x27;class ArticleDetailView(APIView):        throttle_scope = &#x27;article_detail&#x27;\n\n\n\n\n针对不同api接口设置不同限流频率。如下配置代表文章资源列表一天限1000次请求(所有用户访问数量之和)，文章详情接口限1小时100次。\n\nREST_FRAMEWORK = &#123;    &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: [        &#x27;rest_framework.throttling.AnonRateThrottle&#x27;,        &#x27;rest_framework.throttling.UserRateThrottle&#x27;,        &#x27;rest_framework.throttling.ScopedRateThrottle&#x27;,    ],    &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123;        &#x27;anon&#x27;: &#x27;2/min&#x27;,        &#x27;user&#x27;: &#x27;10/min&#x27;,        &#x27;article_list&#x27;:&#x27;1000/day&#x27;, # 新增                &#x27;article_detail&#x27;: &#x27;100/hour&#x27;, # 新增            &#125;  &#125;\n\n","categories":["Django"],"tags":["django","python"]},{"title":"案例实践","url":"/2024/08/09/%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5/","content":"在这篇文章中，我们将带领你一步步构建一个简单的博客项目，其中包括用户的注册和登录功能以及文章详情展示。\n通过这个项目，你将了解如何利用Django处理后台逻辑，并通过Vue.js构建动态的前端界面。\n本项目将分为前后端两部分：Django作为后端，用于处理数据存储、用户认证及API服务；Vue.js作为前端，用于构建用户界面和与后端的交互。前端将通过Axios向后端发出请求并接收响应，完成登录、注册、文章展示等功能。\n环境搭建与工具准备在开始构建项目之前，我们需要搭建开发环境并安装一些必要的工具。本文将使用以下技术栈：\n\nDjango：作为后端框架，处理数据存储、用户认证及API服务。\nVue.js：作为前端框架，负责构建用户界面并与后端交互。\n\n1. 安装 Python 和 Django首先，我们需要安装 Python，这是运行 Django 所必需的。Django 要求 Python 3.6 及以上版本。\n步骤：\n\n安装 Python  \n\n如果你已经安装了 Python 3.x，可以通过以下命令检查版本：python --version\n如果未安装，可以从 Python官网 下载并安装适合你操作系统的版本。\n\n\n创建虚拟环境为了确保项目的依赖与系统环境隔离，建议创建一个虚拟环境：\npython -m venv myenv\n然后激活并进入虚拟环境\nmyenv\\Scripts\\activate\n然后安装django djangorestframework django-cors-headers\n\n\npip install django djangorestframework django-cors-headers\n\n\n你可以通过以下命令检查是否安装成功：\n\npip list\n\n\n2. 创建 Django 项目接下来，我们将创建一个新的 Django 项目：\n\n创建 Django 项目\n\n使用 django-admin 工具来创建一个新的项目，命名为 blog_project：\ndjango-admin startproject blog_project\n\n运行开发服务器\n\n进入项目目录，并启动开发服务器以确认一切正常：\ncd blog_projectpython manage.py runserver\n如果你在浏览器中访问 http://127.0.0.1:8000/，应该会看到 Django 的欢迎页面，表示后端环境搭建成功。\n\n3. 安装 Node.js 和 Vue CLI为了构建前端部分，我们需要安装 Node.js 和 Vue CLI。\n步骤：\n\n安装 Node.js 和 npmNode.js 是 JavaScript 运行时环境，npm 是 Node.js 的包管理工具。你可以从 Node.js 官网 下载并安装最新的 LTS 版本。安装完成后，可以通过以下命令检查版本：\nnode --versionnpm --version\n\n安装 Vue CLIVue CLI 是一个标准化的工具，用于快速搭建 Vue.js 项目。可以通过 npm 安装：\nnpm install -g @vue/cli\n\n验证安装是否成功：\nvue --version\n\n要使用 Vite 和 Vue 搭建项目，按照以下步骤进行：\n创建项目：运行以下命令创建一个 Vue 项目：\nnpm create vite@latest my-vue-app -- --template vue\n安装依赖\ncd my-vue-appnpm install\n\n这一步可能会提示node版本过低，请下载安装nvm(node版本管理器)\n\nnvm list available  #查看有效版本nvm  install 20.0.0 #安装指定版本号的nodenvm use 20.0.0  #切换node版本nvm list #查看当前正在使用的node版本\n启动服务器\nnpm run dev\n\n构建生产版本\nnpm run build\n\n安装 vue-router\n在项目根目录下运行以下命令安装 vue-router：\nnpm install vue-router\n\n在 src 目录下创建一个名为 router 的文件夹，并在其中创建一个 index.js 文件。编辑 src&#x2F;router&#x2F;index.js 文件，配置基本路由：\nimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;import Login from &#x27;../views/Login.vue&#x27;;import Register from &#x27;../views/Register.vue&#x27;;const routes = [&#123;    path: &#x27;/login&#x27;,    name: &#x27;Login&#x27;,    component: Login,&#125;,&#123;    path: &#x27;/register&#x27;,    name: &#x27;Register&#x27;,    component: Register,&#125;,];const router = createRouter(&#123;history: createWebHistory(import.meta.env.BASE_URL),routes,&#125;);export default router;//导出路由实例，在main.js中引用\n在 src&#x2F;views 目录下创建两个 Vue 组件文件：Login.vue 和 Register.vue\n&lt;template&gt;&lt;div&gt;    login &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name: &#x27;Login&#x27;,&#125;;&lt;/script&gt;\n\n   &lt;template&gt;&lt;div&gt;    register &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name: &#x27;Register&#x27;,&#125;;&lt;/script&gt;\n\n打开 src&#x2F;main.js 文件，将 router 添加到 Vue 实例中：\n import &#123; createApp &#125; from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import router from &#x27;./router&#x27;;createApp(App).use(router).mount(&#x27;#app&#x27;);\n更新 App.vue 文件，添加导航链接和路由出口：\n &lt;template&gt;&lt;div id=&quot;app&quot;&gt;    &lt;nav&gt;    &lt;router-link to=&quot;/login&quot;&gt;login&lt;/router-link&gt;    &lt;router-link to=&quot;/register&quot;&gt;register&lt;/router-link&gt;    &lt;/nav&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name: &#x27;App&#x27;,&#125;;&lt;/script&gt;&lt;style&gt;nav &#123;padding: 1rem;background-color: #f0f0f0;&#125;nav a &#123;margin-right: 1rem;&#125;&lt;/style&gt;\n启动开发服务器\n npm run dev\n\n\n要在 Vite 和 Vue 项目中添加 vuex 进行全局状态管理，请按照以下步骤操作：\n二次封装Axios请求库\n安装 npm install axios\n在 src 目录下创建一个名为 services 的文件夹，并在其中创建一个 axios.js 文件： import axios from &#x27;axios&#x27;;import &#123; Toast &#125; from &#x27;vant&#x27;;// 创建一个 axios 实例const instance = axios.create(&#123;    baseURL: &#x27;http://192.168.31.114:8000/&#x27;, // 设置默认的 baseURL    timeout: 10000, // 请求超时时间&#125;);// 请求拦截器instance.interceptors.request.use(    config =&gt; &#123;        // 你可以在这里添加认证令牌或其他请求前的处理        const token = localStorage.getItem(&#x27;jwt_token&#x27;); // 示例：从 localStorage 获取令牌        //let token=&quot;8142bd759b8498ccbaab7d70c14c8e3530ae3117&quot;        if (token) &#123;            config.headers.Authorization = `TOKEN $&#123;token&#125;`;//注意这里有个空格        &#125;        return config;    &#125;,    error =&gt; &#123;        // 请求错误时的处理        Toast.fail(&#x27;请求失败，请稍后再试&#x27;);        return Promise.reject(error);    &#125;);// 响应拦截器instance.interceptors.response.use(    response =&gt; &#123;        // 响应成功时的处理        return response;    &#125;,    error =&gt; &#123;        // 响应错误时的处理        if (error.response) &#123;            // 服务器响应了状态码，但状态码超出了 2xx 范围            console.error(&#x27;Server responded with status:&#x27;, error.response.status);            console.error(&#x27;Response data:&#x27;, error.response.data);            if (error.response.status === 401) &#123;                // 处理未授权错误（例如，令牌过期）                Toast.fail(&#x27;身份认证失败，请重新登录&#x27;);                // 你可以在这里执行一些重定向操作，例如：router.push(&#x27;/login&#x27;);            &#125; else if (error.response.status === 403) &#123;                // 处理禁止访问错误                Toast.fail(&#x27;没有权限访问此资源&#x27;);            &#125; else if (error.response.status === 500) &#123;                // 处理服务器错误                Toast.fail(&#x27;服务器错误，请稍后再试&#x27;);            &#125; else &#123;                // 其他错误                Toast.fail(&#x27;发生错误，请重试&#x27;);            &#125;        &#125; else if (error.request) &#123;            // 请求已发出，但没有收到响应            console.error(&#x27;No response received:&#x27;, error.request);            Toast.fail(&#x27;服务器无响应，请检查网络&#x27;);        &#125; else &#123;            // 其他错误            console.error(&#x27;Error message:&#x27;, error.message);            Toast.fail(&#x27;发生错误，请重试&#x27;);        &#125;        return Promise.reject(error);    &#125;);export default instance;\n\nToast为vant组件，可以根据实际情况修改\n\n\n\n安装vant UI组件\n安装npm install vant@3 -S\n\n\n\n然后在main.js文件中引用import Vant from &#x27;vant&#x27;app.use(Vant)\n\n安装 vuex\n在项目根目录下运行以下命令安装 vuex：\n npm install vuex@next\n\n在 src 目录下创建一个名为 store 的文件夹，并在其中创建一个 index.js 文件：\n import &#123; createStore &#125; from &#x27;vuex&#x27;;import user from &#x27;./user&#x27;;export default createStore(&#123;    state: &#123;    &#125;,    mutactions: &#123;    &#125;,    actions: &#123;    &#125;,    getters: &#123;    &#125;,    modules: &#123;        user: user    &#125;,&#125;)\n再创建一个user.js:\n //这里存用户的所有信息import axios from &#x27;../services/axios&#x27;const store = createStore(&#123;                state:&#123;                        id: &quot;&quot;,                        username: &quot;&quot;,                        is_login: &quot;&quot;,                        token: &quot;&quot;                &#125;,                mutations: &#123;                update_token(state, token) &#123;                    state.token = token                &#125;,                update_info(state, data) &#123;                    state.username = data.username                    state.is_login = true                &#125;,                clear_user_info(state) &#123;                    state.username = &#x27;&#x27;;                    state.is_login = false;                    state.token = &#x27;&#x27;;                &#125;,                                   &#125;,                actions: &#123;                    async login(ctx, data) &#123;                            try &#123;                                const response = await axios(&#123;                                    method: &quot;POST&quot;,                                    headers: &#123;                                        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;                                    &#125;,                                    url: &quot;/user/account/login/&quot;,                                    data: &#123;                                        &quot;username&quot;: data.username,                                        &quot;password&quot;: data.password,                                    &#125;                                &#125;)                                //检查api响应                                if (response.data.state === &#x27;success&#x27;) &#123;                                    console.log(response.data.jwt_token)                                    localStorage.setItem(&quot;authToken&quot;, response.data.jwt_token)                                    ctx.commit(&#x27;update_token&#x27;, response.data.jwt_token)                                    return true                                &#125; else &#123;                                    Toast.fail(response.data.message)                                    return false                                &#125;                            &#125; catch (error) &#123;                                // 其他错误                                console.error(&#x27;Error message:&#x27;, error);                                return false                            &#125;                        &#125;,                                        &#125;,                getters: &#123;                                    &#125;,&#125;);export default store;\n\n使用 Vuex 在组件中访问和操作状态在你的 Vue 组件中，你可以通过以下方式访问和操作全局状态。（比如Login组件中）\n &lt;template&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div title=&quot;登录&quot; class=&quot;login-user-card&quot;&gt;    &lt;h3 class=&quot;title&quot;&gt;        &lt;van-space size=&quot;2rem&quot;&gt;        &lt;router-link :to=&quot;&#123; name: &#x27;login&#x27; &#125;&quot; :class=&quot;&#123; &#x27;active-link&#x27;: $route.name === &#x27;login&#x27; &#125;&quot;&gt;            &lt;span&gt;登录&lt;/span&gt;        &lt;/router-link&gt;        &lt;b&gt;.&lt;/b&gt;        &lt;router-link :to=&quot;&#123; name: &#x27;register&#x27; &#125;&quot; :class=&quot;&#123; &#x27;active-link&#x27;: $route.name === &#x27;register&#x27; &#125;&quot;&gt;            &lt;span&gt;注册&lt;/span&gt;        &lt;/router-link&gt;        &lt;/van-space&gt;    &lt;/h3&gt;    &lt;van-divider /&gt;    &lt;van-form @submit=&quot;onSubmit&quot; @failed=&quot;onFailed&quot;&gt;        &lt;van-cell-group inset&gt;        &lt;van-field v-model=&quot;username&quot; name=&quot;username&quot; label=&quot;用户名&quot; placeholder=&quot;用户名&quot;            :rules=&quot;[&#123; required: true, message: &#x27;请填写用户名&#x27; &#125;]&quot; class=&quot;custom-field &quot; /&gt;        &lt;van-field v-model=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot; label=&quot;密码&quot; placeholder=&quot;密码&quot;            :rules=&quot;[&#123; required: true, message: &#x27;请填写密码&#x27; &#125;]&quot; /&gt;        &lt;van-field style=&quot;visibility: hidden;pointer-events: none;&quot; v-model=&quot;cpatcha&quot; type=&quot;cpatcha&quot; name=&quot;验证码&quot;            label=&quot;验证码&quot; placeholder=&quot;验证码&quot; :rules=&quot;[&#123; required: false, message: &#x27;验证码不正确&#x27; &#125;]&quot; /&gt;        &lt;/van-cell-group&gt;        &lt;div style=&quot;margin: 16px;&quot;&gt;        &lt;van-button round block type=&quot;primary&quot; native-type=&quot;submit&quot;&gt;            登录        &lt;/van-button&gt;        &lt;p class=&quot;sign-up-msg&quot;&gt;点击 “登录” 即表示您同意并愿意遵守&lt;br&gt; &lt;a target=&quot;_blank&quot;            href=&quot;&quot;&gt;用户协议&lt;/a&gt; 和 &lt;a target=&quot;_blank&quot;            href=&quot;&quot;&gt;隐私政策&lt;/a&gt; 。&lt;/p&gt;        &lt;van-divider&gt;还没有账户？            &lt;van-button size=&quot;mini&quot; @click=&quot;goToRegister&quot; type=&quot;success&quot; native-type=&quot;submit&quot;&gt;            去注册            &lt;/van-button&gt;        &lt;/van-divider&gt;        &lt;/div&gt;    &lt;/van-form&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useRouter &#125; from &#x27;vue-router&#x27;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; Toast &#125; from &#x27;vant&#x27;import &#123; useStore &#125; from &#x27;vuex&#x27;const router = useRouter();const store = useStore();const username = ref(&#x27;&#x27;);const password = ref(&#x27;&#x27;);const onSubmit = async (values) =&gt; &#123;try &#123;    const isSuccess = await store.dispatch(&#x27;login&#x27;, &#123;    username: username.value,    password: password.value    &#125;)    if (isSuccess) &#123;    await store.dispatch(&#x27;getinfo&#x27;)//获取新用户的信息    router.push(&#123;name:&quot;index&quot;&#125;)    &#125;&#125; catch (error) &#123;    Toast.fail(&quot;登陆失败或获取个人信息失败&quot;)&#125;&#125;const goToRegister = () =&gt; &#123;router.push(&#123;name:&quot;register&quot;&#125;)&#125;;const onFailed = () =&gt; &#123;Toast.fail(&quot;请重试&quot;)&#125;&lt;/script&gt;\n \n store.dispatch('login', {\n         username: username.value,\n         password: password.value\n         })\n \n \n store.dispatch('getinfo')//获取新用户的信息\n \n\n后端api","categories":["Django"],"tags":["django","python - vue"]},{"title":"自动部署Hexo博客","url":"/2024/10/20/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/","content":"一、创建github仓库创建两个github仓库，一个共有仓库和一个私有仓库。\n私有仓库用来存储Hexo项目源代码用master分支来存放项目源代码\n公有仓库用来存储编译之后的静态页面用gh-pages分支来存储静态页面\n\n\n当私有仓库的master分支有内容push进来时，GitHub Actions 自动编译并且部署到公有仓库的gh-pages分支。\n\n创建GitHub Token创建一个有repo和workflow权限的GitHb Token\n创建repository secret步骤：私有仓库-&gt; settings-&gt;Srcrets-&gt;New repository secrets。\n\n新创建的secrets key在Actions配置文件要用到，因此变量名字要保持一致。\n\n二、添加Actions配置文件1.在你的hexo项目根目录下创建.github文件夹。2.在.github文件夹下继续创建workflows文件夹。2.在workflows文件夹下创建hexo-deploy.yml文件。\nname: deploying Hexo project to GitHub pageson:  push:    branches:      - master # master 分支有 push 行为时就触发这个 actionjobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@v3        with:          fetch-depth: 0      - name: Build and Deploy        uses: theme-keep/hexo-deploy-github-pages-action@master # 使用专门部署 Hexo 到 GitHub pages 的 action        env:          PERSONAL_TOKEN: $&#123;&#123; secrets.HEXO_DEPLOY &#125;&#125; # secret 名          PUBLISH_REPOSITORY: XPoet/keep-blog # 公共仓库，格式：GitHub 用户名/仓库名          BRANCH: gh-pages # 分支，填 gh-pages 就行          PUBLISH_DIR: ./public # 部署 public 目录下的文件\n\n三、触发自动部署流程\n$ hexo init my-blog$ cd my-blog$ npm install$ git init$ git remote add origin 私有仓库的地址$ hexo g$ hexo s\n\ngit add .git commit -m “deploy hexo source”git push -u origin master\n\nGitHub Actions 检测到 master 分支有内容 push 进来，会自动执行 action 配置文件的命令，将 Hexo 项目编译成静态页面，然后部署到公共仓库的 gh-pages 分支。在私有仓库的Actions可以查看配置的action详细信息\n\n","categories":["Hexo"],"tags":["hexo","GitHub Actions"]}]